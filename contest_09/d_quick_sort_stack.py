"""Сдать решение задачи D-Казино.

Однажды Шрек решил сходить в казино. Так как он там был впервые, он решил сыграть в довольно простую игру.

На игровом столе лежат N карточек. На каждой карточке написано целое положительное число. Игра проходит между игроком и
крупье. Карточки лежат на столе числами вниз. Игра заключается в том, что игрок открывает ровно N/2 карточек. Сумма всех
чисел, написанных на карточках, открытых игроком, называется суммой игрока». Следующим ходом крупье открывает оставшиеся
 N/2 карточек. Сумма всех чисел, написанных на карточках открытых крупье, называется «суммой крупье». Выигрыш игрока
 определяется разностью чисел между «суммой игрока» и «суммой крупье». Очевидно, что полученная разность может быть
 отрицательным числом. Это свидетельствует о том, что игрок проиграл и должен казино соответствующую сумму.

Все бы ничего, но Шрек обладает способностью видеть надписи сквозь бумагу любой плотности. Ваша задача определить
максимальную сумму выигрыша, которую может получить Шрек с учётом того, что он видит все числа, написанные на карточках.

Примечание: встроенные сортировки использовать запрещено!

Формат входных данных
Первая строка содержит четное натуральное число N ≤ 10000. На следующей строке через пробел даны N чисел Ai,
1 ≤ Ai ≤ 10E6 — числа на игральных картах.

Формат выходных данных
Одно число — максимальный выигрыш, который может получить Шрек."""


def foo_main(n: int, A: list) -> int:

    quick_sort(A)

    return sum(A[n//2:]) - sum(A[:n//2])


def quick_sort(a: list):

    stack = [0] * (4 + len(a) // 2)  # создаём стек
    k = 0  # дно
    stack[0] = 0  # указатель на позицию левой границы половины
    stack[1] = len(a) - 1  # -||- правой
    while k >= 0:
        i = quick_sort_pos(a, stack[k], stack[k + 1])
        if i != stack[k + 1]:
            RL = i + 1  # левая граница правого подинтервала
        else:
            RL = stack[k + 1]
        RR = stack[k + 1]  # Правая граница правого подинтервала
        LL = stack[k]  # Левая граница левого подинтервала
        if i != stack[k]:
            LR = i - 1  # Правая граница левого подинтервала
        else:
            LR = stack[k]
        k -= 2  # удалить текущий интервал
        if RL != RR:
            k += 2
            stack[k] = RL
            stack[k + 1] = RR
        if LL != LR:
            k += 2
            stack[k] = LL
            stack[k + 1] = LR


def quick_sort_pos(A: list, start: int, stop: int) -> int:

    i = start
    j = stop
    while i < j:
        while A[i] < A[stop]:
            i += 1
        while j > 0 and A[j] >= A[stop]:
            j -= 1
        if i < j:
            A[i], A[j] = A[j], A[i]

    A[stop], A[i] = A[i], A[stop]

    return i


if __name__ == '__main__':
    N, arr = int(input()), list(map(int, input().split()))
    print(foo_main(N, arr))
